{"title":{"titleText":"Процедура Read","type":"Процедура"},"description":[{"type":"text","data":"Считывает значение переменной."},{"type":"subtitle","data":"Объявление:"},{"type":"text","data":"Типизированные файлы:\r\n   Procedure Read(F , V1 [, V2,...,Vn ] );\r\nТекстовые файлы:\r\n   Procedure Read( [ Var F : Text; ] V1 [, V2,...,Vn ] );"},{"type":"subtitle","data":"Замечание:"},{"type":"text","data":"Read считывает все символы до (но не включая) следующего маркера конца строки или пока Eof(F) станет равным True. Read не переходит к следующей строке после чтения. Если полученная в результате строка длиннее, чем максимальная длина строковой переменной, то она усекается. После первого Read, каждые последующие вызовы Read будут видеть маркер конца строки и возвращать строку нулевой длины. Используйте несколько обращений к ReadLn, чтобы считать несколько строковых значений. Когда включена опция Extended Syntax, процедура Read может считывать строки с нулевым окончанием в нуль-основанные массивы символов. Для переменных типа Integer или Real: Read будет пропускать любые пробелы, метки табуляции или маркеры конца строки, предшествующие числовой строке. Если числовая строка не соответствует ожидаемому формату, происходит ошибка ввода/вывода, иначе переменной присваивается полученное значение. Следующий Read начнется с пробела, знака табуляции или маркера конца строки, которые завершали числовую строку."},{"type":"subtitle","data":"Пример:"},{"type":"code","data":"Uses WinCrt, WinDos;\r\n \r\n Var F : Text;\r\n    Ch : Char;\r\n \r\n Begin\r\n  { Получаем имя файла из командной строки }\r\n  Assign(F, ParamStr(1));\r\n  Reset(F);\r\n  While Not EOF(F) Do\r\n  Begin\r\n   Read(F, Ch);\r\n   Write(Ch);  { Выводим содержимое файла на экран }\r\n  End;\r\n End."}]}